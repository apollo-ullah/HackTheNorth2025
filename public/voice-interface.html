<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stacy - Voice Interface</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 100%);
        color: white;
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        overflow: hidden;
      }

      .header {
        position: absolute;
        top: 40px;
        text-align: center;
      }

      .header h1 {
        font-size: 2.5rem;
        font-weight: 600;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .header p {
        font-size: 1.1rem;
        opacity: 0.8;
      }

      .main-layout {
        display: flex;
        height: 100vh;
        padding: 20px;
        gap: 20px;
      }

      .left-panel {
        flex: 1;
        max-width: 400px;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .right-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 40px;
      }

      .voice-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
      }

      .voice-button {
        width: 200px;
        height: 200px;
        border-radius: 50%;
        border: 4px solid rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        user-select: none;
      }

      .voice-button:hover {
        transform: scale(1.05);
        border-color: rgba(255, 255, 255, 0.5);
        background: rgba(255, 255, 255, 0.15);
      }

      .voice-button.listening {
        background: rgba(239, 68, 68, 0.2);
        border-color: #ef4444;
        animation: pulse 2s infinite;
      }

      .voice-button.processing {
        background: rgba(59, 130, 246, 0.2);
        border-color: #3b82f6;
        animation: spin 1s linear infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
        }
        70% {
          box-shadow: 0 0 0 20px rgba(239, 68, 68, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
        }
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .voice-icon {
        font-size: 4rem;
        transition: all 0.3s ease;
      }

      .status-text {
        font-size: 1.2rem;
        font-weight: 500;
        text-align: center;
        min-height: 30px;
        opacity: 0.9;
      }

      .debug-panel {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 8px;
        font-family: "Courier New", monospace;
        font-size: 12px;
        max-width: 300px;
        max-height: 400px;
        overflow-y: auto;
        backdrop-filter: blur(10px);
      }

      .chat-log {
        background: rgba(0, 0, 0, 0.8);
        border-radius: 12px;
        padding: 20px;
        height: 70vh;
        overflow-y: auto;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: flex;
        flex-direction: column;
      }

      .chat-header {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      }

      .chat-header h2 {
        color: #60a5fa;
        font-size: 1.5rem;
        margin-bottom: 5px;
      }

      .chat-header p {
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.9rem;
      }

      .messages-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 15px;
        overflow-y: auto;
        padding-right: 10px;
      }

      .message {
        display: flex;
        flex-direction: column;
        max-width: 80%;
      }

      .message.user {
        align-self: flex-end;
        align-items: flex-end;
      }

      .message.assistant {
        align-self: flex-start;
        align-items: flex-start;
      }

      .message-bubble {
        padding: 12px 16px;
        border-radius: 18px;
        font-size: 14px;
        line-height: 1.4;
        word-wrap: break-word;
      }

      .message.user .message-bubble {
        background: rgba(59, 130, 246, 0.3);
        border: 1px solid rgba(59, 130, 246, 0.5);
        color: white;
      }

      .message.assistant .message-bubble {
        background: rgba(16, 185, 129, 0.3);
        border: 1px solid rgba(16, 185, 129, 0.5);
        color: white;
      }

      .message-info {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.5);
        margin-top: 4px;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .status-panel {
        background: rgba(0, 0, 0, 0.6);
        border-radius: 12px;
        padding: 15px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .conversation-panel h3 {
        margin-bottom: 10px;
        color: #60a5fa;
        font-size: 16px;
      }

      .conversation-message {
        margin-bottom: 12px;
        padding: 8px 12px;
        border-radius: 12px;
        max-width: 85%;
      }

      .conversation-message.user {
        background: rgba(59, 130, 246, 0.3);
        border: 1px solid rgba(59, 130, 246, 0.5);
        margin-left: auto;
        text-align: right;
      }

      .conversation-message.assistant {
        background: rgba(16, 185, 129, 0.3);
        border: 1px solid rgba(16, 185, 129, 0.5);
        margin-right: auto;
      }

      .conversation-message .role {
        font-size: 11px;
        opacity: 0.7;
        margin-bottom: 4px;
        font-weight: 600;
      }

      .conversation-message .content {
        line-height: 1.4;
      }

      .debug-panel h3 {
        margin-bottom: 10px;
        color: #60a5fa;
      }

      .debug-log {
        margin-bottom: 5px;
        padding: 2px 0;
      }

      .debug-log.error {
        color: #ef4444;
      }
      .debug-log.success {
        color: #10b981;
      }
      .debug-log.warning {
        color: #f59e0b;
      }
      .debug-log.info {
        color: #3b82f6;
      }

      .controls {
        position: fixed;
        bottom: 40px;
        display: flex;
        gap: 20px;
        align-items: center;
      }

      .control-button {
        padding: 12px 24px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 25px;
        color: white;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .control-button:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
      }

      .phone-input {
        padding: 12px 20px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 25px;
        color: white;
        font-size: 14px;
        backdrop-filter: blur(10px);
        width: 200px;
        text-align: center;
      }

      .phone-input::placeholder {
        color: rgba(255, 255, 255, 0.6);
      }

      .location-status {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px 15px;
        border-radius: 20px;
        font-size: 12px;
        backdrop-filter: blur(10px);
      }

      .location-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #10b981;
        display: inline-block;
        margin-right: 8px;
      }

      .location-dot.error {
        background: #ef4444;
      }
      .location-dot.warning {
        background: #f59e0b;
      }
    </style>
  </head>
  <body>
    <div class="main-layout">
      <!-- Left Panel: Chat Log -->
      <div class="left-panel">
        <div class="chat-log">
          <div class="chat-header">
            <h2>üí¨ Chat with Stacy</h2>
            <p>Your AI safety companion is listening...</p>
          </div>
          <div class="messages-container" id="messagesContainer">
            <div class="message assistant">
              <div class="message-bubble">
                Hi! I'm Stacy, your AI safety companion. I'm here to help keep
                you safe. How are you feeling right now?
              </div>
              <div class="message-info">
                <span>ü§ñ Stacy</span>
                <span>‚Ä¢</span>
                <span id="initTime"></span>
              </div>
            </div>
          </div>
        </div>

        <div class="status-panel">
          <div id="locationStatus">
            <span class="location-dot" id="locationDot"></span>
            <span id="locationText">Getting location...</span>
          </div>
          <div style="margin-top: 10px">
            <strong>Session:</strong> <span id="sessionDisplay"></span>
          </div>
        </div>
      </div>

      <!-- Right Panel: Voice Interface -->
      <div class="right-panel">
        <div class="header">
          <h1>üõ°Ô∏è Stacy AI Safety Companion</h1>
          <p>Toggle the microphone to start an open conversation</p>
        </div>

        <div class="voice-container">
          <div class="voice-button" id="voiceButton">
            <div class="voice-icon" id="voiceIcon">üé§</div>
          </div>
          <div class="status-text" id="statusText">
            Click to enable open microphone
          </div>
        </div>

        <div class="controls">
          <input
            type="tel"
            class="phone-input"
            id="phoneInput"
            placeholder="Your phone number"
            value="+15146605707"
          />
          <button class="control-button" id="callButton">
            üìû Call Police (VAPI)
          </button>
          <button class="control-button" id="emergencyButton">
            üö® Emergency
          </button>
          <button class="control-button" id="clearChatButton">
            üóëÔ∏è Clear Chat
          </button>
        </div>
      </div>
    </div>

    <div class="debug-panel" id="debugPanel">
      <h3>üîç Debug Log</h3>
      <div id="debugLog"></div>
    </div>

    <script>
      class StacyVoiceInterface {
        constructor() {
          this.isListening = false;
          this.isProcessing = false;
          this.currentLocation = null;
          this.recognition = null;
          this.speechSynthesis = window.speechSynthesis;
          this.isSpeaking = false;

          this.initializeElements();
          this.setupEventListeners();
          this.setupSpeechRecognition();
          this.requestLocationPermission();
          this.showInitTime();

          this.debug(
            "üöÄ Stacy Voice Interface initialized with open mic",
            "success"
          );
        }

        initializeElements() {
          this.voiceButton = document.getElementById("voiceButton");
          this.voiceIcon = document.getElementById("voiceIcon");
          this.statusText = document.getElementById("statusText");
          this.phoneInput = document.getElementById("phoneInput");
          this.callButton = document.getElementById("callButton");
          this.emergencyButton = document.getElementById("emergencyButton");
          this.clearChatButton = document.getElementById("clearChatButton");
          this.debugLog = document.getElementById("debugLog");
          this.locationStatus = document.getElementById("locationStatus");
          this.locationDot = document.getElementById("locationDot");
          this.locationText = document.getElementById("locationText");
          this.messagesContainer = document.getElementById("messagesContainer");
          this.sessionDisplay = document.getElementById("sessionDisplay");

          // Generate session ID for conversation tracking
          this.sessionId = `voice_${Date.now()}_${Math.random()
            .toString(36)
            .substr(2, 9)}`;
          this.debug(`üÜî Session ID: ${this.sessionId}`, "info");
          this.sessionDisplay.textContent = this.sessionId.substr(-8);
        }

        showInitTime() {
          const initTimeEl = document.getElementById("initTime");
          if (initTimeEl) {
            initTimeEl.textContent = new Date().toLocaleTimeString();
          }
        }

        setupEventListeners() {
          this.voiceButton.addEventListener("click", () =>
            this.toggleMicrophone()
          );
          this.callButton.addEventListener("click", () =>
            this.initiateVapiCall()
          );
          this.emergencyButton.addEventListener("click", () =>
            this.triggerEmergency()
          );
          this.clearChatButton.addEventListener("click", () =>
            this.clearChat()
          );

          // Keyboard shortcuts
          document.addEventListener("keydown", (e) => {
            if (e.code === "Space" && !e.repeat && !this.isSpeaking) {
              e.preventDefault();
              this.toggleMicrophone();
            }
          });
        }

        setupSpeechRecognition() {
          if (
            !("webkitSpeechRecognition" in window) &&
            !("SpeechRecognition" in window)
          ) {
            this.debug(
              "üé§ Speech recognition not supported in this browser",
              "error"
            );
            this.statusText.textContent = "Speech recognition not supported";
            return;
          }

          const SpeechRecognition =
            window.SpeechRecognition || window.webkitSpeechRecognition;
          this.recognition = new SpeechRecognition();

          this.recognition.continuous = true;
          this.recognition.interimResults = true;
          this.recognition.lang = "en-US";

          let finalTranscript = "";
          let interimTranscript = "";

          this.recognition.onresult = (event) => {
            finalTranscript = "";
            interimTranscript = "";

            for (let i = event.resultIndex; i < event.results.length; i++) {
              const transcript = event.results[i][0].transcript;
              if (event.results[i].isFinal) {
                finalTranscript += transcript;
              } else {
                interimTranscript += transcript;
              }
            }

            // Show interim results in status
            if (interimTranscript) {
              this.statusText.textContent = `Listening: "${interimTranscript}"`;
            }

            // Process final transcript
            if (finalTranscript.trim()) {
              this.debug(`üó£Ô∏è User said: "${finalTranscript.trim()}"`, "info");
              this.processUserSpeech(finalTranscript.trim());
            }
          };

          this.recognition.onerror = (event) => {
            this.debug(`üé§ Speech recognition error: ${event.error}`, "error");
            if (event.error === "no-speech") {
              // Restart recognition on no-speech error
              setTimeout(() => {
                if (this.isListening) {
                  this.recognition.start();
                }
              }, 1000);
            }
          };

          this.recognition.onend = () => {
            this.debug("üé§ Speech recognition ended", "info");
            // Restart recognition if we're still supposed to be listening
            if (this.isListening && !this.isProcessing) {
              setTimeout(() => {
                try {
                  this.recognition.start();
                } catch (e) {
                  this.debug(
                    `üé§ Failed to restart recognition: ${e.message}`,
                    "error"
                  );
                }
              }, 100);
            }
          };

          this.debug("üé§ Speech recognition setup complete", "success");
        }

        debug(message, type = "info") {
          const timestamp = new Date().toLocaleTimeString();
          const logEntry = document.createElement("div");
          logEntry.className = `debug-log ${type}`;
          logEntry.textContent = `[${timestamp}] ${message}`;

          this.debugLog.appendChild(logEntry);
          this.debugLog.scrollTop = this.debugLog.scrollHeight;

          console.log(`[Stacy Debug] ${message}`);

          // Limit debug log entries
          const logs = this.debugLog.children;
          if (logs.length > 50) {
            this.debugLog.removeChild(logs[0]);
          }
        }

        clearDebug() {
          this.debugLog.innerHTML = "";
          this.debug("Debug log cleared", "info");
        }

        async requestLocationPermission() {
          try {
            this.debug("üìç Requesting location permission...", "info");

            if (!navigator.geolocation) {
              throw new Error("Geolocation not supported");
            }

            const position = await new Promise((resolve, reject) => {
              navigator.geolocation.getCurrentPosition(resolve, reject, {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 60000,
              });
            });

            this.currentLocation = {
              lat: position.coords.latitude,
              lng: position.coords.longitude,
              accuracy: position.coords.accuracy,
            };

            this.locationDot.className = "location-dot";
            this.locationText.textContent = `Location: ¬±${Math.round(
              position.coords.accuracy
            )}m`;

            this.debug(
              `üìç Location obtained: ${this.currentLocation.lat.toFixed(
                4
              )}, ${this.currentLocation.lng.toFixed(4)}`,
              "success"
            );
          } catch (error) {
            this.locationDot.className = "location-dot error";
            this.locationText.textContent = "Location: Access denied";
            this.debug(`üìç Location error: ${error.message}`, "error");
          }
        }

        toggleMicrophone() {
          if (this.isProcessing || this.isSpeaking) {
            this.debug(
              "üö´ Microphone toggle blocked - processing or speaking in progress",
              "warning"
            );
            return;
          }

          if (!this.isListening) {
            this.startOpenMic();
          } else {
            this.stopOpenMic();
          }
        }

        startOpenMic() {
          try {
            if (!this.recognition) {
              this.debug("üé§ Speech recognition not available", "error");
              return;
            }

            this.debug("üé§ Starting open microphone...", "info");

            this.isListening = true;
            this.voiceButton.classList.add("listening");
            this.voiceIcon.textContent = "üî¥";
            this.statusText.textContent =
              "Open mic active - Stacy is listening";

            this.recognition.start();
            this.debug("üé§ Open microphone started", "success");
          } catch (error) {
            this.debug(
              `üé§ Failed to start open mic: ${error.message}`,
              "error"
            );
            this.statusText.textContent = "Failed to start microphone";
          }
        }

        stopOpenMic() {
          try {
            this.debug("‚èπÔ∏è Stopping open microphone...", "info");

            this.isListening = false;
            this.voiceButton.classList.remove("listening");
            this.voiceIcon.textContent = "üé§";
            this.statusText.textContent = "Click to enable open microphone";

            if (this.recognition) {
              this.recognition.stop();
            }

            this.debug("‚èπÔ∏è Open microphone stopped", "success");
          } catch (error) {
            this.debug(`‚èπÔ∏è Error stopping open mic: ${error.message}`, "error");
          }
        }

        async processUserSpeech(transcript) {
          if (this.isProcessing || this.isSpeaking) {
            this.debug(
              "üö´ Ignoring speech - already processing or speaking",
              "warning"
            );
            return;
          }

          try {
            this.isProcessing = true;
            this.statusText.textContent = "Stacy is thinking...";

            // Add user message to chat
            this.addMessageToChat("user", transcript);

            // Get Stacy's response
            const response = await this.chatWithStacy(transcript);

            if (response && response.reply) {
              // Add Stacy's response to chat
              this.addMessageToChat("assistant", response.reply);

              // Show tool results if any
              if (response.toolResult) {
                this.handleToolResult(response.action, response.toolResult);
              }

              // Speak Stacy's response
              await this.speakResponse(response.reply);

              // Handle escalation
              if (response.action === "escalate_to_police") {
                this.debug(
                  "üö® Escalating to police - initiating VAPI call",
                  "warning"
                );
                await this.initiateVapiCall();
              }
            }
          } catch (error) {
            this.debug(`üîÑ Error processing speech: ${error.message}`, "error");
            this.addMessageToChat(
              "system",
              "Error processing your message. Please try again."
            );
          } finally {
            this.isProcessing = false;
            if (this.isListening) {
              this.statusText.textContent =
                "Open mic active - Stacy is listening";
            } else {
              this.statusText.textContent = "Click to enable open microphone";
            }
          }
        }

        async processAudioRecording() {
          try {
            this.isProcessing = true;
            this.debug("üîÑ Processing audio recording...", "info");

            if (this.audioChunks.length === 0) {
              throw new Error("No audio data recorded");
            }

            const audioBlob = new Blob(this.audioChunks, {
              type: "audio/webm",
            });
            this.debug(
              `üîÑ Audio blob created: ${audioBlob.size} bytes`,
              "info"
            );

            // For now, we'll simulate processing and use text-to-speech
            // In a real implementation, you'd send this to a speech-to-text service
            await this.simulateAudioProcessing(audioBlob);
          } catch (error) {
            this.debug(`üîÑ Audio processing error: ${error.message}`, "error");
            this.statusText.textContent = "Error processing audio";
          } finally {
            this.isProcessing = false;
            this.voiceButton.classList.remove("processing");
            this.voiceIcon.textContent = "üé§";
            this.statusText.textContent = "Click to start talking to Stacy";
          }
        }

        async processAudioRecording() {
          try {
            this.isProcessing = true;
            this.debug("üîÑ Processing audio recording...", "info");

            if (this.audioChunks.length === 0) {
              throw new Error("No audio data recorded");
            }

            const audioBlob = new Blob(this.audioChunks, {
              type: "audio/webm",
            });
            this.debug(
              `üîÑ Audio blob created: ${audioBlob.size} bytes`,
              "info"
            );

            // Convert audio to text and chat with Stacy
            await this.processVoiceInput(audioBlob);
          } catch (error) {
            this.debug(`üîÑ Audio processing error: ${error.message}`, "error");
            this.statusText.textContent = "Error processing audio";
          } finally {
            this.isProcessing = false;
            this.voiceButton.classList.remove("processing");
            this.voiceIcon.textContent = "üé§";
            this.statusText.textContent = "Click to start talking to Stacy";
          }
        }

        async processVoiceInput(audioBlob) {
          try {
            // Step 1: Convert speech to text
            this.statusText.textContent = "Converting speech to text...";
            const transcript = await this.speechToText(audioBlob);

            if (!transcript) {
              this.statusText.textContent =
                "Could not understand speech. Try again.";
              return;
            }

            this.debug(`üó£Ô∏è User said: "${transcript}"`, "info");
            this.statusText.textContent = `You said: "${transcript}"`;

            // Step 2: Get Stacy's response
            this.statusText.textContent = "Stacy is thinking...";
            const response = await this.chatWithStacy(transcript);

            if (!response) {
              this.statusText.textContent = "Error getting response from Stacy";
              return;
            }

            this.debug(`ü§ñ Stacy responded: "${response.reply}"`, "info");

            // Step 3: Speak Stacy's response
            this.statusText.textContent = "Stacy is speaking...";
            await this.textToSpeech(response.reply);

            // Step 4: Handle any actions (like police escalation)
            if (response.action === "escalate_to_police") {
              this.debug(
                "üö® Escalating to police - initiating VAPI call",
                "warning"
              );
              this.statusText.textContent =
                "Escalating to emergency services...";
              await this.initiateVapiCall();
            } else {
              this.statusText.textContent =
                "Click to continue talking to Stacy";
            }
          } catch (error) {
            this.debug(`üîÑ Voice processing error: ${error.message}`, "error");
            this.statusText.textContent = "Error processing voice input";
          }
        }

        async speechToText(audioBlob) {
          try {
            this.debug(
              "üé§ Converting speech to text with OpenAI Whisper...",
              "info"
            );

            // Use OpenAI Whisper for high-quality speech recognition
            const formData = new FormData();
            formData.append("audio", audioBlob, "audio.webm");
            formData.append("model", "whisper-1");
            formData.append("language", "en");

            const response = await fetch("/api/stacy/transcribe", {
              method: "POST",
              body: formData,
            });

            if (response.ok) {
              const result = await response.json();
              this.debug(`üé§ Whisper transcription: "${result.text}"`, "info");
              return result.text;
            } else {
              throw new Error(`Transcription API error: ${response.status}`);
            }
          } catch (error) {
            this.debug(
              `üé§ Whisper error, using fallback: ${error.message}`,
              "warning"
            );

            // Fallback to simulated messages for demo
            const sampleMessages = [
              "I need help, someone is following me",
              "I feel unsafe walking alone",
              "There's a suspicious person nearby",
              "Can you help me find a safe place",
              "I'm scared and need assistance",
              "Someone is making me uncomfortable",
              "Can you call the police for me",
              "Hello Stacy, I need your help",
            ];

            const messageIndex =
              Math.floor(audioBlob.size / 1000) % sampleMessages.length;
            const simulatedText = sampleMessages[messageIndex];

            this.debug(
              `üé§ Using simulated message: "${simulatedText}"`,
              "info"
            );
            return simulatedText;
          }
        }

        // Alternative: Use Web Speech API for real-time recognition
        async startRealtimeSpeechRecognition() {
          return new Promise((resolve, reject) => {
            if (
              !("webkitSpeechRecognition" in window) &&
              !("SpeechRecognition" in window)
            ) {
              reject(new Error("Speech recognition not supported"));
              return;
            }

            const SpeechRecognition =
              window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();

            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = "en-US";

            recognition.onresult = (event) => {
              const transcript = event.results[0][0].transcript;
              this.debug(
                `üé§ Real-time speech recognition: "${transcript}"`,
                "info"
              );
              resolve(transcript);
            };

            recognition.onerror = (event) => {
              this.debug(
                `üé§ Speech recognition error: ${event.error}`,
                "error"
              );
              reject(new Error(event.error));
            };

            recognition.onend = () => {
              this.debug("üé§ Speech recognition ended", "info");
            };

            recognition.start();

            // Timeout after 10 seconds
            setTimeout(() => {
              recognition.stop();
              reject(new Error("Speech recognition timeout"));
            }, 10000);
          });
        }

        async chatWithStacy(userMessage) {
          try {
            this.debug(`üí¨ Sending message to Stacy: "${userMessage}"`, "info");

            const response = await fetch("/api/stacy/chat", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                message: userMessage,
                location: this.currentLocation,
                sessionId: this.sessionId,
              }),
            });

            if (!response.ok) {
              throw new Error(`Chat API error: ${response.status}`);
            }

            const result = await response.json();
            this.debug(
              `üí¨ Stacy response: ${JSON.stringify(result, null, 2)}`,
              "info"
            );

            return result;
          } catch (error) {
            this.debug(`üí¨ Chat error: ${error.message}`, "error");
            // Fallback response
            return {
              reply:
                "I'm here to help you stay safe. Can you tell me more about your situation?",
              action: null,
            };
          }
        }

        addMessageToChat(role, content) {
          const messageDiv = document.createElement("div");
          messageDiv.className = `message ${role}`;

          const bubbleDiv = document.createElement("div");
          bubbleDiv.className = "message-bubble";
          bubbleDiv.textContent = content;

          const infoDiv = document.createElement("div");
          infoDiv.className = "message-info";

          const roleSpan = document.createElement("span");
          roleSpan.textContent =
            role === "user"
              ? "üë§ You"
              : role === "assistant"
              ? "ü§ñ Stacy"
              : "‚öôÔ∏è System";

          const timeSpan = document.createElement("span");
          timeSpan.textContent = new Date().toLocaleTimeString();

          infoDiv.appendChild(roleSpan);
          infoDiv.appendChild(document.createTextNode(" ‚Ä¢ "));
          infoDiv.appendChild(timeSpan);

          messageDiv.appendChild(bubbleDiv);
          messageDiv.appendChild(infoDiv);

          this.messagesContainer.appendChild(messageDiv);
          this.messagesContainer.scrollTop =
            this.messagesContainer.scrollHeight;

          // Limit chat history to last 50 messages
          const messages = this.messagesContainer.children;
          if (messages.length > 50) {
            this.messagesContainer.removeChild(messages[1]); // Keep the initial message
          }
        }

        clearChat() {
          // Keep only the initial Stacy message
          const initialMessage = this.messagesContainer.children[0];
          this.messagesContainer.innerHTML = "";
          this.messagesContainer.appendChild(initialMessage);

          this.debug("üóëÔ∏è Chat log cleared", "info");
        }

        handleToolResult(action, toolResult) {
          this.debug(`üîß Tool result for ${action}:`, "info");

          switch (action) {
            case "safe_locations_found":
              if (toolResult.locations && toolResult.locations.length > 0) {
                const locationsList = toolResult.locations
                  .slice(0, 3)
                  .map(
                    (loc) => `üìç ${loc.name} - ${loc.distance}km (${loc.type})`
                  )
                  .join("\n");
                this.addMessageToChat(
                  "system",
                  `Safe locations found:\n${locationsList}`
                );
              }
              break;

            case "contact_notified":
              if (toolResult.success) {
                this.addMessageToChat(
                  "system",
                  `‚úÖ Emergency contact notified successfully! SMS ID: ${toolResult.messageId}`
                );
              } else {
                this.addMessageToChat(
                  "system",
                  `‚ùå Failed to notify contact: ${toolResult.error}`
                );
              }
              break;

            default:
              this.debug(`üîß Unhandled tool result: ${action}`, "warning");
          }
        }

        async speakResponse(text) {
          try {
            this.isSpeaking = true;
            this.statusText.textContent = "üîä Stacy is speaking...";
            this.debug(
              `üîä Generating high-quality voice for: "${text}"`,
              "info"
            );

            // Use OpenAI's high-quality TTS
            const response = await fetch("/api/stacy/voice", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                text: text,
                voice: "nova", // Female voice optimized for conversations
              }),
            });

            if (!response.ok) {
              throw new Error(`Voice API error: ${response.status}`);
            }

            const result = await response.json();

            if (result.success) {
              this.debug(
                `üîä Generated ${result.audio.length} chars of base64 audio`,
                "info"
              );

              // Convert base64 to audio and play
              const audioData = `data:audio/mp3;base64,${result.audio}`;
              const audio = new Audio(audioData);

              return new Promise((resolve) => {
                audio.onloadeddata = () => {
                  this.debug("üîä Audio loaded, starting playback", "info");
                };

                audio.onplay = () => {
                  this.debug("üîä High-quality speech started", "info");
                };

                audio.onended = () => {
                  this.debug("üîä High-quality speech completed", "info");
                  this.isSpeaking = false;
                  resolve();
                };

                audio.onerror = (error) => {
                  this.debug(`üîä Audio playback error: ${error}`, "error");
                  this.isSpeaking = false;
                  resolve(); // Don't block on audio errors
                };

                audio.play().catch((e) => {
                  this.debug(`üîä Audio play failed: ${e.message}`, "error");
                  this.isSpeaking = false;
                  resolve();
                });
              });
            } else {
              throw new Error("Voice generation failed");
            }
          } catch (error) {
            this.debug(`üîä OpenAI voice error: ${error.message}`, "error");

            // Fallback to browser TTS
            this.debug("üîä Falling back to browser TTS", "warning");
            return this.fallbackTextToSpeech(text);
          }
        }

        async fallbackTextToSpeech(text) {
          try {
            if ("speechSynthesis" in window) {
              speechSynthesis.cancel();

              return new Promise((resolve) => {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.9;
                utterance.pitch = 1.1;
                utterance.volume = 1.0;

                utterance.onend = () => {
                  this.isSpeaking = false;
                  resolve();
                };

                utterance.onerror = () => {
                  this.isSpeaking = false;
                  resolve();
                };

                speechSynthesis.speak(utterance);
              });
            } else {
              this.isSpeaking = false;
            }
          } catch (error) {
            this.debug(`üîä Fallback TTS error: ${error.message}`, "error");
            this.isSpeaking = false;
          }
        }

        async initiateVapiCall() {
          try {
            const phoneNumber = this.phoneInput.value.trim();

            if (!phoneNumber) {
              this.debug("üìû No phone number provided", "warning");
              this.statusText.textContent =
                "Please enter your phone number first";
              return;
            }

            this.debug(
              `üìû Initiating VAPI call to police for ${phoneNumber}...`,
              "info"
            );
            this.statusText.textContent = "Connecting to emergency services...";

            const requestData = {
              phone_number: phoneNumber,
              user_location: this.currentLocation,
              emergency_contacts: [
                {
                  name: "Emergency Contact",
                  phone: "+15146605707",
                  relationship: "Primary",
                },
              ],
            };

            this.debug(
              `üìû Emergency call request: ${JSON.stringify(
                requestData,
                null,
                2
              )}`,
              "info"
            );

            const response = await fetch("/api/stacy/voice-call", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(requestData),
            });

            const result = await response.json();

            this.debug(
              `üìû VAPI response: ${JSON.stringify(result, null, 2)}`,
              "info"
            );

            if (result.success) {
              this.statusText.textContent = `üö® Emergency call initiated! You will receive a call from ${result.stacyNumber} to connect with emergency services.`;
              this.debug(
                `üìû Emergency call successful! Call ID: ${result.callId}`,
                "success"
              );

              // Add to chat log
              this.addMessageToChat(
                "assistant",
                "Emergency services have been contacted. You will receive a call shortly to connect you with a dispatcher."
              );
            } else {
              this.statusText.textContent = `Emergency call failed: ${result.error}`;
              this.debug(`üìû Emergency call failed: ${result.error}`, "error");
            }
          } catch (error) {
            this.debug(`üìû Emergency call error: ${error.message}`, "error");
            this.statusText.textContent =
              "Failed to contact emergency services";
            console.error("Emergency call error:", error);
          }
        }

        async triggerEmergency() {
          try {
            this.debug("üö® Emergency triggered!", "warning");
            this.statusText.textContent = "Emergency mode activated...";

            if (!this.currentLocation) {
              this.debug("üö® No location available for emergency", "error");
              this.statusText.textContent = "Emergency: Location required";
              return;
            }

            const emergencyData = {
              action: "quick_alert",
              location: this.currentLocation,
              message: "EMERGENCY: Alert activated from Stacy voice interface",
              emergency_contact: {
                name: "Emergency Contact",
                phone: "+15146605707",
                relationship: "Primary",
              },
            };

            this.debug(
              `üö® Emergency data: ${JSON.stringify(emergencyData, null, 2)}`,
              "warning"
            );

            const response = await fetch("/api/stacy/mobile", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(emergencyData),
            });

            const result = await response.json();

            this.debug(
              `üö® Emergency response: ${JSON.stringify(result, null, 2)}`,
              "info"
            );

            if (result.success) {
              this.statusText.textContent = `Emergency alert sent! Message ID: ${result.messageId}`;
              this.debug("üö® Emergency alert sent successfully", "success");

              // Add to chat log
              this.addMessageToChat(
                "system",
                "üö® Emergency alert sent to your emergency contact!"
              );

              // Also initiate a call after a short delay
              setTimeout(() => this.initiateVapiCall(), 1000);
            } else {
              this.statusText.textContent = `Emergency failed: ${result.error}`;
              this.debug(`üö® Emergency failed: ${result.error}`, "error");
              this.addMessageToChat(
                "system",
                `‚ùå Emergency alert failed: ${result.error}`
              );
            }
          } catch (error) {
            this.debug(`üö® Emergency error: ${error.message}`, "error");
            this.statusText.textContent = "Emergency system error";
          }
        }
      }

      // Initialize when page loads
      document.addEventListener("DOMContentLoaded", () => {
        window.stacyVoice = new StacyVoiceInterface();
      });
    </script>
  </body>
</html>
